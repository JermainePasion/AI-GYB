#include <Wire.h>
#include <I2Cdev.h>
#include <MPU6050.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>

// ================= MPU6050 CONFIG =================
MPU6050 mpu(0x68);
const float gyroY_offset = 76.35;
const float gyroZ_offset = 27.96;
const float GYRO_SENS = 16.4;

float angleY = 0, angleZ = 0;
float angleY_zero = 0, angleZ_zero = 0;
unsigned long lastSampleTime = 0;

// ================= FLEX SENSOR CONFIG =================
const int flexPin = 34;   // Flex sensor connected here
int flexBaseline = -1;
const float maxFlexAngle = 90.0;
const int bendThreshold = 100;

// ================= POSTURE THRESHOLDS =================
// Mock thresholds (-30 to +30 for everything)
float flex_min = -30, flex_max = 30;
float gyroY_min = -30, gyroY_max = 30;
float gyroZ_min = -30, gyroZ_max = 30;

// ================= VIBRATION MOTOR =================
const int vibMotorPin = 32; // Blue wire to G32, red to GND

// ================= MOTOR CONFIG =================
#define PWMA 25
#define AIN1 18
#define AIN2 19

#define PWMB 14
#define BIN1 26
#define BIN2 27

#define STBY 23  // if using TB6612FNG; comment out if L298N

// ================= BLE CONFIG =================
#define SERVICE_UUID        "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"

BLECharacteristic *pCharacteristic;

// BLE callback to receive new thresholds
class MyCallbacks: public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic *pCharacteristic) {
    String value = pCharacteristic->getValue().c_str();
    if (value.length() > 0) {
      Serial.print("üì• Received thresholds: ");
      Serial.println(value);

      // Parse comma-separated values
      sscanf(value.c_str(), "%f,%f,%f,%f,%f,%f",
        &flex_min, &flex_max, &gyroY_min, &gyroY_max, &gyroZ_min, &gyroZ_max);

      Serial.printf("‚úÖ Updated thresholds ‚Üí Flex[%.1f-%.1f] | GyroY[%.1f-%.1f] | GyroZ[%.1f-%.1f]\n",
                    flex_min, flex_max, gyroY_min, gyroY_max, gyroZ_min, gyroZ_max);
    }
  }
};

// --- Helper: map flex sensor to angle ---
float mapFlexToAngle(int value) {
  int deviation = abs(value - flexBaseline);
  float angle = (float)deviation * (maxFlexAngle / bendThreshold);
  return (angle > maxFlexAngle) ? maxFlexAngle : angle;
}

// --- Helper: smoothing filter ---
float smooth(float newValue, float prevValue, float factor = 0.9) {
  return factor * prevValue + (1 - factor) * newValue;
}

// --- Motor helpers ---
void runMotorA() {
  digitalWrite(AIN1, HIGH);
  digitalWrite(AIN2, LOW);
  digitalWrite(PWMA, HIGH);
}

void runMotorB() {
  digitalWrite(BIN1, HIGH);
  digitalWrite(BIN2, LOW);
  digitalWrite(PWMB, HIGH);
}

void stopMotors() {
  digitalWrite(PWMA, LOW);
  digitalWrite(PWMB, LOW);
}

void setup() {
  Serial.begin(115200);

  // ========== BLE INIT ==========
  BLEDevice::init("AI-GYB");
  BLEServer *pServer = BLEDevice::createServer();
  BLEService *pService = pServer->createService(SERVICE_UUID);

  pCharacteristic = pService->createCharacteristic(
    CHARACTERISTIC_UUID,
    BLECharacteristic::PROPERTY_READ |
    BLECharacteristic::PROPERTY_WRITE |
    BLECharacteristic::PROPERTY_NOTIFY
  );
  pCharacteristic->addDescriptor(new BLE2902());
  pCharacteristic->setCallbacks(new MyCallbacks());

  pService->start();
  pServer->getAdvertising()->start();
  Serial.println("üì° BLE Ready. Waiting for connection...");

  // ========== MPU6050 INIT ==========
  Wire.begin(21, 22);
  mpu.initialize();
  Serial.printf("üìü WHO_AM_I = 0x%X\n", mpu.getDeviceID());

  // Flex baseline
  flexBaseline = analogRead(flexPin);
  Serial.printf("üìè Flex baseline set to: %d\n", flexBaseline);

  // Calibrate MPU baseline
  long sumY = 0, sumZ = 0;
  for (int i = 0; i < 100; i++) {
    int16_t ax, ay, az;
    mpu.getAcceleration(&ax, &ay, &az);
    float accelAngleY = atan2(-ax, sqrt(ay * ay + az * az)) * 180.0 / PI;
    float accelAngleZ = atan2(ay, ax) * 180.0 / PI;
    sumY += accelAngleY;
    sumZ += accelAngleZ;
    delay(10);
  }
  angleY_zero = sumY / 100.0;
  angleZ_zero = sumZ / 100.0;

  // Motor setup
  pinMode(PWMA, OUTPUT);
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH); // enable driver

  pinMode(vibMotorPin, OUTPUT);
  digitalWrite(vibMotorPin, LOW);

  Serial.println("‚úÖ System ready. Monitoring sensors...");
}

void runVibrationMotor() {
  digitalWrite(BIN1, HIGH);
  digitalWrite(BIN2, LOW);
  digitalWrite(PWMB, HIGH);
}

void stopVibrationMotor() {
  digitalWrite(PWMB, LOW);
}

void loop() {
  unsigned long now = millis();
  float dt = (now - lastSampleTime) / 1000.0;
  lastSampleTime = now;

  // Gyro
  int16_t gx, gy, gz;
  mpu.getRotation(&gx, &gy, &gz);
  float gy_dps = (gy - gyroY_offset) / GYRO_SENS;
  float gz_dps = (gz - gyroZ_offset) / GYRO_SENS;

  // Accel
  int16_t ax, ay, az;
  mpu.getAcceleration(&ax, &ay, &az);
  float accelAngleY = atan2(-ax, sqrt(ay * ay + az * az)) * 180.0 / PI;
  float accelAngleZ = atan2(ay, ax) * 180.0 / PI;

  float accelAngleY_relative = accelAngleY - angleY_zero;
  float accelAngleZ_relative = accelAngleZ - angleZ_zero;

  // Complementary filter
  float gyroAngleY = angleY + gy_dps * dt;
  float gyroAngleZ = angleZ + gz_dps * dt;

  const float alphaY = 0.90;
  const float alphaZ = 0.85;

  angleY = alphaY * gyroAngleY + (1 - alphaY) * accelAngleY_relative;
  angleZ = alphaZ * gyroAngleZ + (1 - alphaZ) * accelAngleZ_relative;

  angleY = smooth(angleY, accelAngleY_relative, 0.95);
  angleZ = smooth(angleZ, accelAngleZ_relative, 0.98);

  if (angleY < 0) angleY = 0;        // clamp negatives
  if (abs(angleZ) < 1.0) angleZ = 0; // deadband for noise

  int flexValue = analogRead(flexPin);
  float flexAngle = mapFlexToAngle(flexValue);

  // === Debug print ===
  Serial.printf("Flex: %.2f¬∞ | GyroY: %.2f¬∞ | GyroZ: %.2f¬∞\n", flexAngle, angleY, angleZ);

  // === Notify frontend ===
  char buffer[50];
  snprintf(buffer, sizeof(buffer), "%.2f,%.2f,%.2f", flexAngle, angleY, angleZ);
  pCharacteristic->setValue(buffer);
  pCharacteristic->notify();

  // === Posture check ===
  if (flexAngle < flex_min || flexAngle > flex_max ||
      angleY < gyroY_min || angleY > gyroY_max ||
      angleZ < gyroZ_min || angleZ > gyroZ_max) {
    Serial.println("‚ö†Ô∏è Bad posture detected! Motors ON (one side)");
    digitalWrite(vibMotorPin, HIGH);

    // Run only Motor A (example side)
    runMotorA();
    runMotorB(); 
    runVibrationMotor();

  } else {
    digitalWrite(vibMotorPin, LOW);
    stopMotors();
    stopVibrationMotor();
  }

  delay(100); // fast updates
}
